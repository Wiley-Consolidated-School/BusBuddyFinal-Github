name: .NET Build and Test

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  workflow_dispatch:  # Allow manual triggering

# Environment variables used across multiple jobs
env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for better versioning
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    # Minimal setup - only install what we actually need
    - name: Install SQLite (Alternative approach)
      run: |
        Write-Host "Setting up SQLite..."
        # Try using winget first (modern Windows package manager)
        try {
          winget install --id SQLite.SQLite --silent --accept-source-agreements --accept-package-agreements
          Write-Host "SQLite installed via winget"
        }
        catch {
          Write-Host "Winget failed, trying alternative approach..."
          # If winget fails, try chocolatey
          try {
            if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
              Set-ExecutionPolicy Bypass -Scope Process -Force
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
            }
            choco install sqlite -y --no-progress
            Write-Host "SQLite installed via chocolatey"
          }
          catch {
            Write-Host "Both winget and chocolatey failed, SQLite may need to be handled differently"
            Write-Host "Continuing without SQLite installation - tests should still work with embedded SQLite"
          }
        }
        
    - name: List repository contents
      run: |
        Write-Host "Repository contents:"
        Get-ChildItem -Force | Format-Table -AutoSize
        if (Test-Path "BusBuddy.sln") { 
          Write-Host "✓ Solution file found in root" 
        } else { 
          Write-Host "✗ Solution file not found in root, searching subdirectories..."
          Get-ChildItem -Recurse -Filter "*.sln" | ForEach-Object { Write-Host "Found: $($_.FullName)" }
        }
        
    - name: Find solution file
      id: find-solution
      run: |
        $solutionPath = (Get-ChildItem -Path . -Filter *.sln -Recurse | Select-Object -First 1).FullName
        if ($solutionPath) {
          Write-Host "Solution file found at: $solutionPath"
          "SOLUTION_PATH=$solutionPath" >> $env:GITHUB_ENV
          "solution_path=$solutionPath" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "No solution file found in the repository"
          exit 1
        }
        
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
        
    - name: Restore dependencies
      run: dotnet restore $env:SOLUTION_PATH
      
    - name: Build
      run: dotnet build $env:SOLUTION_PATH --no-restore --configuration Release
    
    # Create TestResults directory to ensure it exists
    - name: Create TestResults directory
      run: |
        if (-not (Test-Path "TestResults")) {
          New-Item -ItemType Directory -Path "TestResults"
          Write-Host "Created TestResults directory"
        } else {
          Write-Host "TestResults directory already exists"
        }
        
    # Run tests with proper TRX generation
    - name: Run tests
      run: |
        Write-Host "Running tests with TRX output..."
        dotnet test $env:SOLUTION_PATH --configuration Release --verbosity normal --logger "trx;LogFileName=test-results.trx" --results-directory TestResults --collect:"XPlat Code Coverage"
        
        # Verify TRX files were created
        if (Test-Path "TestResults/*.trx") {
          Write-Host "✓ TRX files generated successfully:"
          Get-ChildItem "TestResults/*.trx" | ForEach-Object { Write-Host "  - $($_.Name)" }
        } else {
          Write-Host "✗ No TRX files found in TestResults directory"
          Write-Host "Contents of TestResults:"
          Get-ChildItem "TestResults" -Recurse | ForEach-Object { Write-Host "  - $($_.FullName)" }
        }
        
    # Upload test results as artifacts (always runs)
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: TestResults/
        retention-days: 30
        
    # Generate test report (only if we have TRX files)
    - name: Test Report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: XUnit Tests
        path: TestResults/*.trx
        reporter: dotnet-trx
        fail-on-error: false
        
    # Upload coverage reports
    - name: Upload coverage reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-reports
        path: TestResults/**/coverage.cobertura.xml
        retention-days: 30
        
    # Optional: Code coverage reporting (if you want Codecov integration)
    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v3
      with:
        file: TestResults/**/coverage.cobertura.xml
        fail_ci_if_error: false
        verbose: true
        
  # Separate job for deployment readiness checks
  deployment-check:
    runs-on: windows-latest
    needs: build
    if: github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    - name: Build Release version
      run: |
        dotnet restore
        dotnet build --configuration Release --no-restore
        
    - name: Create deployment package
      run: |
        dotnet publish --configuration Release --output ./deploy/
        
    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package
        path: deploy/
        retention-days: 7

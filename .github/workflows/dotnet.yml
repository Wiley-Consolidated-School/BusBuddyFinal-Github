name: .NET Build and Test

on:
  push:
    branches: [ "master" ]
  pull_request:
    branches: [ "master" ]
  workflow_dispatch:  # Allow manual triggering

# Add permissions for test reporting
permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write

# Environment variables used across multiple jobs
env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true

jobs:
  build:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for better versioning
        
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
        
    # Simplified SQLite setup - embedded SQLite works for tests
    - name: Setup SQLite (Optional)
      run: |
        Write-Host "Checking SQLite availability..."
        Write-Host "Note: Tests use embedded SQLite and will work without system SQLite"
        # Optional: Try to install SQLite if needed for development
        try {
          if (Get-Command sqlite3 -ErrorAction SilentlyContinue) {
            Write-Host "✓ SQLite already available"
          } else {
            Write-Host "SQLite not found, but tests will use embedded version"
          }
        }
        catch {
          Write-Host "SQLite check completed - using embedded SQLite for tests"
        }
        
    - name: List repository contents
      run: |
        Write-Host "Repository contents:"
        Get-ChildItem -Force | Format-Table -AutoSize
        if (Test-Path "BusBuddy.sln") { 
          Write-Host "✓ Solution file found in root" 
        } else { 
          Write-Host "✗ Solution file not found in root, searching subdirectories..."
          Get-ChildItem -Recurse -Filter "*.sln" | ForEach-Object { Write-Host "Found: $($_.FullName)" }
        }
        
    - name: Find solution file
      id: find-solution
      run: |
        if (Test-Path "BusBuddy.sln") {
          $solutionPath = (Resolve-Path "BusBuddy.sln").Path
          Write-Host "Solution file found at: $solutionPath"
          "SOLUTION_PATH=$solutionPath" >> $env:GITHUB_ENV
          "solution_path=$solutionPath" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "No solution file found in the repository"
          exit 1
        }
        
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
        
    - name: Restore dependencies
      run: dotnet restore $env:SOLUTION_PATH
      
    - name: Build
      run: dotnet build $env:SOLUTION_PATH --no-restore --configuration Release
    
    # Create TestResults directory to ensure it exists
    - name: Create TestResults directory
      run: |
        if (-not (Test-Path "TestResults")) {
          New-Item -ItemType Directory -Path "TestResults"
          Write-Host "Created TestResults directory"
        } else {
          Write-Host "TestResults directory already exists"
        }
        
    # Run tests with proper TRX generation
    - name: Run tests
      run: |
        Write-Host "Running tests with TRX output..."
        dotnet test $env:SOLUTION_PATH --configuration Release --verbosity normal --logger "trx;LogFileName=test-results.trx" --results-directory TestResults --collect:"XPlat Code Coverage"
        
        # Verify TRX files were created
        if (Test-Path "TestResults/*.trx") {
          Write-Host "✓ TRX files generated successfully:"
          Get-ChildItem "TestResults/*.trx" | ForEach-Object { Write-Host "  - $($_.Name)" }
        } else {
          Write-Host "✗ No TRX files found in TestResults directory"
          Write-Host "Contents of TestResults:"
          Get-ChildItem "TestResults" -Recurse | ForEach-Object { Write-Host "  - $($_.FullName)" }
        }
        
    # Upload test results as artifacts (always runs)
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: TestResults/
        retention-days: 30
        
    # Generate test report (only if we have TRX files)
    - name: Test Report
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: XUnit Tests
        path: TestResults/*.trx
        reporter: dotnet-trx
        fail-on-error: false
        
    # Upload coverage reports
    - name: Upload coverage reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: coverage-reports
        path: TestResults/**/coverage.cobertura.xml
        retention-days: 30
      # Optional: Code coverage reporting (with token for rate limit handling)
    - name: Upload coverage to Codecov
      if: always()
      uses: codecov/codecov-action@v4
      with:
        files: TestResults/**/coverage.cobertura.xml
        fail_ci_if_error: false
        verbose: true
        token: ${{ secrets.CODECOV_TOKEN }}
        
  # Separate job for deployment readiness checks
  deployment-check:
    runs-on: windows-latest
    needs: build
    if: github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x        
    - name: Build Release version
      run: |
        dotnet restore BusBuddy.sln
        dotnet build BusBuddy.sln --configuration Release --no-restore
        
    - name: Create deployment package
      run: |
        dotnet publish --configuration Release --output ./deploy/
        
    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package
        path: deploy/
        retention-days: 7
